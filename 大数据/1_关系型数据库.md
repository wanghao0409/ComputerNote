关系型数据库



# 第一节、关系型数据库



# 1、索引是什么？包括哪几类？

**索引的分类**包括**主键索引、唯一索引、普通索引、全文索引和组合索引**。选择合适的索引类型可以优化查询性能，但过多的索引可能影响数据写入速度。

## 一、按逻辑功能分类

### 1. 主键索引（Primary Key）

sql

```
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 主键索引
    name VARCHAR(100)
);
```



**特点：**

- 唯一且非空
- 通常是聚簇索引

### 2. 唯一索引（Unique Index）

sql

```
CREATE UNIQUE INDEX idx_email ON users(email);
```



**特点：**

- 保证列值唯一
- 允许NULL值（具体看数据库实现）

### 3. 普通索引（Normal Index）

sql

```
CREATE INDEX idx_name ON users(name);
```



**特点：**

- 最基本的索引类型
- 不保证唯一性

### 4. 复合索引（Composite Index）

sql

```
CREATE INDEX idx_name_age ON users(last_name, first_name, age);
```



**特点：**

- 多列组合索引
- 遵循最左前缀原则
- 支持索引覆盖查询

### 5. 前缀索引（Prefix Index）

sql

```
-- 只对字段的前N个字符建立索引
CREATE INDEX idx_name_prefix ON users(name(10));
```



**特点：**

- 减少索引大小
- 可能影响选择性

### 6. 函数索引（Function-based Index）

sql

```
-- Oracle/PostgreSQL
CREATE INDEX idx_upper_name ON users(UPPER(name));
-- MySQL 8.0+
CREATE INDEX idx_functional ON users((LOWER(email)));
```



**特点：**

- 基于函数或表达式
- 支持大小写不敏感查询等场景

## 二、按数据结构分类

### 1. B-Tree索引（最常用）

sql

```
-- MySQL/PostgreSQL的默认索引类型
CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_composite ON users(last_name, first_name);
```



**特点：**

- 平衡多路搜索树
- 支持范围查询、排序、前缀匹配
- 适用于等值查询和范围查询

### 2. 哈希索引

sql

```
-- MySQL Memory引擎支持
CREATE INDEX idx_hash ON users(name) USING HASH;
-- PostgreSQL Hash索引
CREATE INDEX idx_hash ON users USING hash(email);
```



**特点：**

- 基于哈希表实现
- 只支持等值查询（=, IN）
- 不支持范围查询和排序
- 查询性能O(1)

### 3. 全文索引

sql

```
-- MySQL
CREATE FULLTEXT INDEX idx_content ON articles(content);
-- PostgreSQL
CREATE INDEX idx_gin ON documents USING gin(to_tsvector('english', content));
```



**特点：**

- 用于文本内容的全文搜索
- 支持关键词搜索、相关性排序

### 4. R-Tree索引（空间索引）

sql

```
-- MySQL
CREATE SPATIAL INDEX idx_location ON maps(coordinates);
-- PostgreSQL
CREATE INDEX idx_gist ON spatial_data USING gist(geometry_column);
```



**特点：**

- 用于地理空间数据
- 支持距离查询、范围查询等

### 5. 位图索引

sql

```
-- Oracle/PostgreSQL
CREATE BITMAP INDEX idx_status ON orders(status);
```



**特点：**

- 适用于低基数列（性别、状态等）
- 多个位图索引可以快速进行AND/OR操作

## 三、按物理存储分类

### 1. 聚簇索引（Clustered Index）

sql

```
-- InnoDB中主键自动成为聚簇索引
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 聚簇索引
    name VARCHAR(100)
);
```



**特点：**

- 数据按索引顺序物理存储
- 一个表只能有一个聚簇索引
- 主键通常是聚簇索引

### 2. 非聚簇索引（Non-Clustered Index）

sql

```
-- 普通索引都是非聚簇索引
CREATE INDEX idx_email ON users(email);
```



**特点：**

- 索引和数据分开存储
- 一个表可以有多个非聚簇索引
- 需要回表查询

## 四、按覆盖范围分类

### 1. 覆盖索引（Covering Index）

sql

```
-- 索引包含查询所需的所有列
CREATE INDEX idx_covering ON users(id, name, email);
-- 查询时不需要回表
SELECT id, name FROM users WHERE id = 1;
```



**特点：**

- 索引包含查询需要的所有字段
- 避免回表操作，性能最佳

### 2. 部分索引（Partial Index）

sql

```
-- PostgreSQL/Oracle
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';
```



**特点：**

- 只对部分数据建立索引
- 减少索引大小，提高效率

# 什么是缓慢变化维（SCD）？如何处理？**

- **回答要点**：维度表中某些属性会随时间变化（如客户地址）。

  - **类型1**：直接覆盖旧值（不保留历史）。
  - **类型2**：添加新行，标记生效时间（保留历史）。
  - **类型3**：添加新列记录旧值（仅保留有限历史）。

  



# 数据库的三大范式是什么？

数据库的三大范式是：

1. **第一范式（1NF）**：确保每列的值都是不可分割的原子值。**确保原子性**
2. **第二范式（2NF）**：在满足第一范式的基础上，确保每个非主属性完全依赖于主键。**消除部分依赖。**
3. **第三范式（3NF）**：在满足第二范式的基础上，确保每个非主属性不传递依赖于主键。**消除传递依赖。**

# 事务ACID

在数据库管理中，ACID特性是确保数据库事务正确执行的四个基本要素，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这些特性保证了在多用户环境下，数据库能够提供可靠的事务处理。

## 原子性（Atomicity）

原子性意味着事务中的所有操作要么全部成功，要么全部失败。如果事务中的任何操作失败，整个事务将回滚到开始状态，就像这个事务从未执行过一样。这确保了事务是一个不可分割的工作单位。

## 一致性（Consistency）

一致性确保数据库在事务开始之前和结束之后保持一致状态。所有事务必须遵守数据库的规则，包括数据的完整性约束。无论事务的结果如何，数据库都必须保持一致性。

## 隔离性（Isolation）

隔离性保证了事务的独立性。即使多个事务同时执行，每个事务的操作和数据对其他事务都是隔离的。这避免了多个事务并发执行时可能出现的数据不一致问题。

## 持久性（Durability）

持久性意味着一旦事务提交，它对数据库的更改就是永久性的。即使发生系统故障，已提交的事务也不会丢失。





# 数据库分区分表

