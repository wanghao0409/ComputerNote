# SQL

SQL (Structured Query Language) 

结构化查询语言

# 第一部分  标准SQL(按功能分类)

## 一、数据定义 ( DDL)

DDL全称是Data Definition Language，即数据定义语言，定义语言就是定义关系模式、删除关系、修改关系模式以及创建数据库中的各种对象，比如表、聚簇、索引、视图、函数、存储过程和触发器等等。
```sql
CREATE --创建数据库对象（表、视图、索引等）

ALTER -- 修改数据库对象结构

DROP -- 删除数据库对象

TRUNCATE -- 删除表中的所有数据

RENAME -- 重命名数据库对象

COMMENT -- 添加注释到数据字典
```


  索引

  视图

## 二、数据操作 ( DML)

Data Manipulation Language

- `INSERT` - 向表中插入新记录

- `UPDATE` - 更新表中的记录

- `DELETE` - 删除表中的记录

- `MERGE`/`UPSERT` - 插入或更新记录

- `CALL` - 调用存储过程

- `EXPLAIN` - 显示查询执行计划

  

## 三、数据查询（DQL)

Data Query Language -

### 1、查询过程（关键字执行顺序）

| 顺序  | 关键字              |                    主要功能 | 说明                                                 |
| :-- | :--------------- | ----------------------: | :------------------------------------------------- |
| 1   | **`FROM`**       |              指定表并选择基础数据 | 首先确定数据的来源，这是所有操作的基础。                               |
| 2   | **`ON`**         |             应用JOIN的连接条件 | 与`JOIN`一起，根据条件筛选两个表中可以连接的行。                        |
| 3   | **`JOIN`**       |      将满足条件的行从连接表添加到结果集中 | 执行实际的连接操作（如LEFT JOIN会保留左表所有行）。                     |
| 4   | **`WHERE`**      |        对连接后的临时结果集进行行级过滤 | **无法**在此阶段使用SELECT中定义的别名或聚合函数。                     |
| 5   | **`GROUP BY`**   |       对过滤后的数据按照指定的列进行分组 | 将多行数据分组为单个行，为聚合计算做准备。                              |
| 6   | **`HAVING`**     |        对**分组后**的组数据进行过滤 | **可以**使用聚合函数（如`HAVING SUM(sales) > 1000`），WHERE不能。 |
|     | window functions |                    窗口函数 |                                                    |
| 7   | **`SELECT`**     | 选择要返回的列，计算表达式，并**分配别名** | 在此阶段，计算`CASE`表达式、窗口函数等。别名在此阶段才被确认。                 |
| 8   | **`DISTINCT`**   |                  去除重复的行 | 在SELECT结果出来后，才进行去重。                                |
| 9   | **`ORDER BY`**   |             对最终的结果集进行排序 | **可以**使用SELECT阶段定义的别名。这是唯一能使用别名的后续阶段。              |
| 10  | **`LIMIT`**      |                 限制返回的行数 | 最后一步，在排序后截取指定的行数。                                  |

```sql
select distinct column_name as new_column_name
from 
join 
on   -- 逻辑上是先产生笛卡尔积再用on筛选，实际上先筛选再连接
where
group by
having 
order by
limit 
```

### 2. JOIN ON 关键字

#### 5.1 join 连接方式





#### 5.2 **JOIN 的 ON 条件和 WHERE 条件有什么区别？**

- **`ON` 条件**：指定**如何连接**两个表。它决定了哪些行是匹配的。在 `OUTER JOIN` 中，`ON` 条件不影响主表的结果集数量，只决定从表如何匹配。

- **`WHERE` 条件**：在连接完成后，**过滤**结果集。它会影响最终返回的所有行。

  

#### **5.3. JOIN 的执行流程是怎样的？数据库真的会先产生笛卡尔积吗？**

- **逻辑上**：是的，我们可以理解为先产生笛卡尔积，再用 `ON` 条件过滤。这是理解 `JOIN` 结果的最佳方式。

- **物理上**：**绝对不是！** 数据库优化器会使用高效的算法来避免巨大的笛卡尔积。常见算法有：

  - **Nested Loop Join**：适用于一张表很小，另一张表有索引的情况。

  - **Hash Join**：适用于大数据集。先对一张表构建哈希表，再用另一张表去探测。

  - **Sort-Merge Join**：先对两张表按连接键排序，然后进行归并。

    

#### 5.4 **如何提高 JOIN 查询的性能？**

- **索引**：**在连接条件字段（`ON` 子句中的字段）上创建索引**是最有效的手段。例如，在 `employees.dept_id` 和 `departments.dept_id` 上都建立索引。
- **小表驱动大表**：在Nested Loop Join中，让数据量小的表作为驱动表（外表），可以减少循环次数。
- **只选择必要的列**：避免 `SELECT *`，减少数据传输量。
- **提前过滤**：在连接之前，先用子查询或 `WHERE` 条件将每个表的数据量尽可能减小。



### 3. WHERE 关键字

#### 3.1、**WHERE 和 HAVING 的区别是什么？**

- **答案**：这是最经典的面试题。
  \* **`WHERE`**：在**分组前（GROUP BY）** 过滤**行**。它不能包含聚合函数（如SUM, COUNT）。
  \* **`HAVING`**：在**分组后（GROUP BY）** 过滤**组**。它通常与聚合函数一起使用，用于过滤掉不满足条件的组。

#### 3.2 **如何查询某个字段为 NULL 的记录？能用 `= NULL` 吗？**

- **答案**：**不能**用 `= NULL` 或 `!= NULL`。因为 NULL 代表未知，任何与 NULL 的比较结果也都是未知（NULL），`WHERE` 条件只会筛选出结果为 True 的行。
- **正确写法**：必须使用 `IS NULL` 或 `IS NOT NULL`。

#### 3.3  BETWEEN 和 IN 操作符的使用**

- **答案**：
  \* `BETWEEN ... AND ...`：用于范围查询，是**闭区间** [ ]。`WHERE price BETWEEN 10 AND 20` 包含10和20。
  \* `IN (...)`：用于匹配一个列表中的任何值。`WHERE department_id IN (10, 20, 30)`。

#### 3.4  **LIKE 操作符中，`%` 和 `_` 有什么区别？**

- **答案**：
  \* `%`：匹配任意字符（包括0个字符）。
  \* `_`：匹配单个任意字符。
- **示例**：
  \* `NAME LIKE '张%'`：找出所有姓“张”的人（张三、张三丰）。
  \* `NAME LIKE '张_'`：找出姓“张”且名字只有两个字的人（张三，找不到“张三丰”）。

#### 3.5  **如何提高 LIKE 查询的性能？**

- **答案**：`LIKE`以通配符`%`开头的查询无法使用索引（如 `LIKE '%abc'`），会导致全表扫描，性能极差。
- **优化方案**：
  \1. 尽量避免前缀通配符`%`。如果必须使用，考虑使用全文检索（如Elasticsearch）。
  \2. 如果后缀查询（`LIKE 'abc%'`），可以建立索引来加速。
  \3. 查询 `LIKE '%abc%'` 同样无法使用索引，是性能杀手。

#### 3.6  **EXISTS 和 IN 在子查询中的区别？**

- **答案**：
  \* `IN`：先执行子查询，将结果集缓存起来，然后主查询再去这个结果集中进行匹配。**适合子查询结果集较小的情况**。
  \* `EXISTS`：不关心子查询返回的具体数据，只关心**子查询是否有结果返回**。对于主查询的每一行，都会执行一次子查询，如果子查询能返回至少一行记录，则条件为真。**适合主查询结果集小，子查询关联字段有索引的情况**。

- **性能**：没有绝对谁快谁慢，取决于数据分布和索引情况。但通常在外表大、内表小用`IN`；外表小、内表大用`EXISTS`。

  

### 4. GROUP BY 与HAVING 关键字

#### 4.1. GROUP BY 的作用是什么？它和聚合函数有什么关系？

- **答案**：`GROUP BY` 子句用于将查询结果集按一列或多列进行分组，**值相等的为一组**。它通常与聚合函数（`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`）一起使用，目的是**为每个组计算一个汇总值**。
- **关系**：没有 `GROUP BY`，聚合函数作用于整个结果集（返回一行）。有了 `GROUP BY`，聚合函数作用于每个组（返回多行，每组一行）。

#### 4.2. WHERE 和 HAVING 在与 GROUP BY 配合时，有什么区别？

- **答案**：这是最经典的面试题，必须熟练掌握。
  \* **`WHERE`**：在 **分组之前** 过滤数据。它从原始数据中筛选行，**不能使用聚合函数**。
  `WHERE` -> `GROUP BY` -> `HAVING`
  \* **`HAVING`**：在 **分组之后** 过滤数据。它从分组后的结果中筛选组，**必须使用聚合函数**或分组字段。

#### **4.3 SELECT 列表中的非聚合列是否必须出现在 GROUP BY 子句中？**

- **答案**：**是的**。这是 `GROUP BY` 最严格的语法规则。`SELECT` 子句中出现的列，如果不是聚合函数的参数，**就必须出现在 `GROUP BY` 子句中**，否则 SQL 引擎无法确定这个非聚合值该显示组内的哪一个。
- **错误示例**：
  `sql -- 错误：name 没有出现在 GROUP BY 中，也不是聚合参数 SELECT department_id, name, COUNT(*) FROM employees GROUP BY department_id;`
- **MySQL 的例外**：在 MySQL 的某些模式下，允许不遵守此规则，它会随机返回组内的一个`name`值。但这是**不标准且危险的行为**，应绝对避免。

### 6. SELECT DISTINCT ORDERY LIMIT

#### 6.1、select * 、select count(1) 和select count(*)有什么区别

select * 用来查询所有数据，我只有在知道要查询的表数据量较小的情况下使用

select count(*)  用来统计要查询的表的行数，select count(1)与其一样

select count(column_name)  **统计特定列的非空行数**



### 7. 窗口函数

7.1 什么是窗口函数？常见有哪些？

**定义**：窗口函数（Window Function）也被称为OLAP（Online Analytical Processing）函数。它对一组与**当前行相关**的行进行计算，**但不像`GROUP BY`那样将行折叠成一行输出，而是保留所有行的同时，为每一行返回一个值**。

**核心语法**：

sql

```sql
<窗口函数> OVER (
    [PARTITION BY <列名>]  -- 用于分组，类似GROUP BY，但不会合并行
    [ORDER BY <列名> [ASC|DESC]] -- 用于组内排序，决定了计算的顺序
    [ROWS|RANGE <frame_clause>] -- 定义窗口框架，即计算的数据范围
)
```



#### 排名、排序窗口函数

| 函数               | 描述                                                         | 特点                   |
| :----------------- | :----------------------------------------------------------- | :--------------------- |
| **`ROW_NUMBER()`** | 排序。为组内的每一行分配一个**唯一的连续序号**（1, 2, 3, ...） | 即使值相同，序号也不同 |
| **`RANK()`**       | 排名。**值相同时排名相同，但会跳过后续排名** (1, 1, 3, 4)    | 会出现排名“跳跃”       |
| **`DENSE_RANK()`** | 密集排名。**值相同时排名相同，且不会跳过后续排名** (1, 1, 2, 3) | 排名是连续的           |
| **NTILE()**        |                                                              |                        |

#### 前后位移窗口函数

这类函数用于访问当前行之前或之后的行，非常强大。

| 函数                  | 描述                            |
| :-------------------- | :------------------------------ |
| **`LAG(column, n)`**  | 返回当前行**之前第`n`行**的值。 |
| **`LEAD(column, n)`** | 返回当前行**之后第`n`行**的值。 |

#### 聚合窗口函数

所有常见的聚合函数（`SUM`, `AVG`, `COUNT`, `MAX`, `MIN`）都可以作为窗口函数使用，实现**<u>累计</u>计算**。





## 四、数据控制 (DCL)

数据控制语言：Data Control Language。用来授权或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，能够对数据库进行监视。

- `GRANT` - 授予用户访问权限
- `REVOKE` - 撤销用户访问权限
- `DENY` - 拒绝特定权限

## 五、事务控制 (TCL)

Transaction Control

- `COMMIT` - 提交事务
- `ROLLBACK` - 回滚事务
- `SAVEPOINT` - 在事务中设置保存点
- `SET TRANSACTION` - 设置事务特性
- `BEGIN`/`START TRANSACTION` - 开始事务



# 存储过程



# 第三部分 Hive SQL





# 第四部分 Spark SQL 