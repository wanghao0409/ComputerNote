# Flink

Flink 是一个**有状态的、容错的、高吞吐低延迟**的**流处理框架**，其核心观点是“**万物皆流**”。

# **面试官可能会问：** “简单介绍一下 Flink。”

**你的回答（30秒版）：**
“Flink 是一个分布式的流处理引擎，它的核心设计思想是‘批流一体’。也就是说，它用一套引擎同时处理无界数据流（实时数据）和有界数据流（历史数据）。

它最大的优势是提供了**精确一次**的状态一致性保障、**高吞吐**和**毫秒级延迟**，非常适合实时ETL、实时监控、风控等场景。”

# 1. 批 vs. 流 & 有界 vs. 无界

- **批处理**：处理**有界**数据，比如一个HDFS文件，处理完就结束。
- **流处理**：处理**无界**数据，比如Kafka里的消息流，数据源源不断，任务持续运行。
- **Flink的“批流一体”**：Flink认为批（有界数据）是流（无界数据）的一个特例。所以用同一套API和运行时来处理两者。

# 2. 有状态计算

这是Flink的灵魂！

- **无状态**：每个数据的处理不依赖其他数据。比如 `map`、`filter`，处理每条数据时都是独立的。
- **有状态**：处理当前数据时，需要依赖之前计算过的数据或中间结果。这个“之前的数据”就是**状态**。
  - **典型例子**：
    - **窗口聚合**：计算最近5分钟的销售额总和。这个“总和”就是状态。
    - **去重**：统计1小时内有多少独立用户访问。需要保存已出现的用户ID，这也是状态。
    - **模式匹配**：检测“登录后5分钟内下单”的规则。需要记住用户登录的事件，这还是状态。

# 3. 时间语义

这是流处理中最容易混淆也最重要的一点。

- **处理时间**：数据被算子处理时的**系统时间**。最简单，但结果不确定。
- **事件时间**：数据**自身产生的时间**（比如传感器记录的时间戳）。这能保证处理结果的准确性，即使数据乱序或延迟到达。
- **摄入时间**：数据进入Flink源算子的时间。用得较少。

**面试官可能会问：** “如何处理乱序数据？”
**你的回答：** “使用**事件时间**语义，并配合**水位线** 机制。

**水位线是**一种逻辑时钟，它表示‘所有时间戳小于等于T的数据都已经到达了’。这样，当水位线推进到窗口结束时间时，就可以触发窗口计算了。为了容忍一定的延迟，我们还可以设置**允许延迟时间**。”

# 4. 窗口

因为流数据是无界的，我们要做聚合（如求和、计数），就必须划定一个范围，这个范围就是窗口。

- **滚动窗口**：窗口之间不重叠。如：每5分钟一个窗口。`[0:00-0:05), [0:05-0:10)`
- **滑动窗口**：窗口之间有重叠。如：每5分钟计算一次最近10分钟的数据。窗口大小 > 滑动步长。
- **会话窗口**：根据数据的活跃度来划分窗口，一段时间没有收到新数据，窗口就关闭。

# 5. 容错与精确一次

**如何保证数据不丢不重？** 这是生产环境必须考虑的问题。

- **检查点**checkpoint：Flink的“存档点”。定期将**所有算子的状态**做一个快照，持久化到远程存储（如HDFS）。这个快照是**异步**的，不影响正常处理性能。
- **精确一次保障的实现**：
  - **两阶段提交**：Flink 与外部系统（如Kafka）协作，通过“预提交 -> 提交”的机制，保证端到端的精确一次。
  - **面试简述**：“Flink 使用 **Chandy-Lampora 算法**定期做分布式快照（检查点）。当任务失败时，可以从最近一个成功的检查点恢复所有算子的状态，并重新处理之后的数据，从而做到状态和计算的‘精确一次’。”