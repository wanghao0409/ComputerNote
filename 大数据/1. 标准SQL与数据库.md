# SQL

SQL (Structured Query Language) 

结构化查询语言

# 第一部分  标准SQL(按功能分类)

## 一、数据定义 ( DDL)

DDL全称是Data Definition Language，即数据定义语言，定义语言就是定义关系模式、删除关系、修改关系模式以及创建数据库中的各种对象，比如表、聚簇、索引、视图、函数、存储过程和触发器等等。
```sql
CREATE --创建数据库对象（表、视图、索引等）

ALTER -- 修改数据库对象结构

DROP -- 删除数据库对象

TRUNCATE -- 删除表中的所有数据

RENAME -- 重命名数据库对象

COMMENT -- 添加注释到数据字典
```


  索引

  视图

## 二、数据操作 ( DML)

Data Manipulation Language

- `INSERT` - 向表中插入新记录

- `UPDATE` - 更新表中的记录

- `DELETE` - 删除表中的记录

- `MERGE`/`UPSERT` - 插入或更新记录

- `CALL` - 调用存储过程

- `EXPLAIN` - 显示查询执行计划

  

## 三、数据查询（DQL)

Data Query Language -

### 1、查询过程（关键字执行顺序）

| 顺序  | 关键字              |                    主要功能 | 说明                                                 |
| :-- | :--------------- | ----------------------: | :------------------------------------------------- |
| 1   | **`FROM`**       |              指定表并选择基础数据 | 首先确定数据的来源，这是所有操作的基础。                               |
| 2   | **`ON`**         |             应用JOIN的连接条件 | 与`JOIN`一起，根据条件筛选两个表中可以连接的行。                        |
| 3   | **`JOIN`**       |      将满足条件的行从连接表添加到结果集中 | 执行实际的连接操作（如LEFT JOIN会保留左表所有行）。                     |
| 4   | **`WHERE`**      |        对连接后的临时结果集进行行级过滤 | **无法**在此阶段使用SELECT中定义的别名或聚合函数。                     |
| 5   | **`GROUP BY`**   |       对过滤后的数据按照指定的列进行分组 | 将多行数据分组为单个行，为聚合计算做准备。                              |
| 6   | **`HAVING`**     |        对**分组后**的组数据进行过滤 | **可以**使用聚合函数（如`HAVING SUM(sales) > 1000`），WHERE不能。 |
|     | window functions |                    窗口函数 |                                                    |
| 7   | **`SELECT`**     | 选择要返回的列，计算表达式，并**分配别名** | 在此阶段，计算`CASE`表达式、窗口函数等。别名在此阶段才被确认。                 |
| 8   | **`DISTINCT`**   |                  去除重复的行 | 在SELECT结果出来后，才进行去重。                                |
| 9   | **`ORDER BY`**   |             对最终的结果集进行排序 | **可以**使用SELECT阶段定义的别名。这是唯一能使用别名的后续阶段。              |
| 10  | **`LIMIT`**      |                 限制返回的行数 | 最后一步，在排序后截取指定的行数。                                  |

```sql
select distinct column_name as new_column_name
from 
join 
on   -- 逻辑上是先产生笛卡尔积再用on筛选，实际上先筛选再连接
where
group by
having 
order by
limit 
```

### 2. JOIN ON 关键字

#### 5.1 join 连接方式





#### 5.2 **JOIN 的 ON 条件和 WHERE 条件有什么区别？**

- **`ON` 条件**：指定**如何连接**两个表。它决定了哪些行是匹配的。在 `OUTER JOIN` 中，`ON` 条件不影响主表的结果集数量，只决定从表如何匹配。

- **`WHERE` 条件**：在连接完成后，**过滤**结果集。它会影响最终返回的所有行。

  

#### **5.3. JOIN 的执行流程是怎样的？数据库真的会先产生笛卡尔积吗？**

- **逻辑上**：是的，我们可以理解为先产生笛卡尔积，再用 `ON` 条件过滤。这是理解 `JOIN` 结果的最佳方式。

- **物理上**：**绝对不是！** 数据库优化器会使用高效的算法来避免巨大的笛卡尔积。常见算法有：

  - **Nested Loop Join**：适用于一张表很小，另一张表有索引的情况。

  - **Hash Join**：适用于大数据集。先对一张表构建哈希表，再用另一张表去探测。

  - **Sort-Merge Join**：先对两张表按连接键排序，然后进行归并。

    

#### 5.4 **如何提高 JOIN 查询的性能？**

- **索引**：**在连接条件字段（`ON` 子句中的字段）上创建索引**是最有效的手段。例如，在 `employees.dept_id` 和 `departments.dept_id` 上都建立索引。
- **小表驱动大表**：在Nested Loop Join中，让数据量小的表作为驱动表（外表），可以减少循环次数。
- **只选择必要的列**：避免 `SELECT *`，减少数据传输量。
- **提前过滤**：在连接之前，先用子查询或 `WHERE` 条件将每个表的数据量尽可能减小。



### 3. WHERE 关键字

#### 3.1、**WHERE 和 HAVING 的区别是什么？**

- **答案**：这是最经典的面试题。
  \* **`WHERE`**：在**分组前（GROUP BY）** 过滤**行**。它不能包含聚合函数（如SUM, COUNT）。
  \* **`HAVING`**：在**分组后（GROUP BY）** 过滤**组**。它通常与聚合函数一起使用，用于过滤掉不满足条件的组。

#### 3.2 **如何查询某个字段为 NULL 的记录？能用 `= NULL` 吗？**

- **答案**：**不能**用 `= NULL` 或 `!= NULL`。因为 NULL 代表未知，任何与 NULL 的比较结果也都是未知（NULL），`WHERE` 条件只会筛选出结果为 True 的行。
- **正确写法**：必须使用 `IS NULL` 或 `IS NOT NULL`。

#### 3.3  BETWEEN 和 IN 操作符的使用**

- **答案**：
  \* `BETWEEN ... AND ...`：用于范围查询，是**闭区间** [ ]。`WHERE price BETWEEN 10 AND 20` 包含10和20。
  \* `IN (...)`：用于匹配一个列表中的任何值。`WHERE department_id IN (10, 20, 30)`。

#### 3.4  **LIKE 操作符中，`%` 和 `_` 有什么区别？**

- **答案**：
  \* `%`：匹配任意字符（包括0个字符）。
  \* `_`：匹配单个任意字符。
- **示例**：
  \* `NAME LIKE '张%'`：找出所有姓“张”的人（张三、张三丰）。
  \* `NAME LIKE '张_'`：找出姓“张”且名字只有两个字的人（张三，找不到“张三丰”）。

#### 3.5  **如何提高 LIKE 查询的性能？**

- **答案**：`LIKE`以通配符`%`开头的查询无法使用索引（如 `LIKE '%abc'`），会导致全表扫描，性能极差。
- **优化方案**：
  \1. 尽量避免前缀通配符`%`。如果必须使用，考虑使用全文检索（如Elasticsearch）。
  \2. 如果后缀查询（`LIKE 'abc%'`），可以建立索引来加速。
  \3. 查询 `LIKE '%abc%'` 同样无法使用索引，是性能杀手。

#### 3.6  **EXISTS 和 IN 在子查询中的区别？**

- **答案**：
  \* `IN`：先执行子查询，将结果集缓存起来，然后主查询再去这个结果集中进行匹配。**适合子查询结果集较小的情况**。
  \* `EXISTS`：不关心子查询返回的具体数据，只关心**子查询是否有结果返回**。对于主查询的每一行，都会执行一次子查询，如果子查询能返回至少一行记录，则条件为真。**适合主查询结果集小，子查询关联字段有索引的情况**。

- **性能**：没有绝对谁快谁慢，取决于数据分布和索引情况。但通常在外表大、内表小用`IN`；外表小、内表大用`EXISTS`。

  

### 4. GROUP BY 与HAVING 关键字

#### 4.1. GROUP BY 的作用是什么？它和聚合函数有什么关系？

- **答案**：`GROUP BY` 子句用于将查询结果集按一列或多列进行分组，**值相等的为一组**。它通常与聚合函数（`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`）一起使用，目的是**为每个组计算一个汇总值**。
- **关系**：没有 `GROUP BY`，聚合函数作用于整个结果集（返回一行）。有了 `GROUP BY`，聚合函数作用于每个组（返回多行，每组一行）。

#### 4.2. WHERE 和 HAVING 在与 GROUP BY 配合时，有什么区别？

- **答案**：这是最经典的面试题，必须熟练掌握。
  \* **`WHERE`**：在 **分组之前** 过滤数据。它从原始数据中筛选行，**不能使用聚合函数**。
  `WHERE` -> `GROUP BY` -> `HAVING`
  \* **`HAVING`**：在 **分组之后** 过滤数据。它从分组后的结果中筛选组，**必须使用聚合函数**或分组字段。

#### **4.3 SELECT 列表中的非聚合列是否必须出现在 GROUP BY 子句中？**

- **答案**：**是的**。这是 `GROUP BY` 最严格的语法规则。`SELECT` 子句中出现的列，如果不是聚合函数的参数，**就必须出现在 `GROUP BY` 子句中**，否则 SQL 引擎无法确定这个非聚合值该显示组内的哪一个。
- **错误示例**：
  `sql -- 错误：name 没有出现在 GROUP BY 中，也不是聚合参数 SELECT department_id, name, COUNT(*) FROM employees GROUP BY department_id;`
- **MySQL 的例外**：在 MySQL 的某些模式下，允许不遵守此规则，它会随机返回组内的一个`name`值。但这是**不标准且危险的行为**，应绝对避免。

### 6. SELECT DISTINCT ORDERY LIMIT

#### 6.1、select * 、select count(1) 和select count(*)有什么区别

select * 用来查询所有数据，我只有在知道要查询的表数据量较小的情况下使用

select count(*)  用来统计要查询的表的行数，select count(1)与其一样

select count(column_name)  **统计特定列的非空行数**



### 7. 窗口函数

7.1 什么是窗口函数？常见有哪些？

**定义**：窗口函数（Window Function）也被称为OLAP（Online Analytical Processing）函数。它对一组与**当前行相关**的行进行计算，**但不像`GROUP BY`那样将行折叠成一行输出，而是保留所有行的同时，为每一行返回一个值**。

**核心语法**：

sql

```sql
<窗口函数> OVER (
    [PARTITION BY <列名>]  -- 用于分组，类似GROUP BY，但不会合并行
    [ORDER BY <列名> [ASC|DESC]] -- 用于组内排序，决定了计算的顺序
    [ROWS|RANGE <frame_clause>] -- 定义窗口框架，即计算的数据范围
)
```



#### 排名、排序窗口函数

| 函数               | 描述                                                         | 特点                   |
| :----------------- | :----------------------------------------------------------- | :--------------------- |
| **`ROW_NUMBER()`** | 排序。为组内的每一行分配一个**唯一的连续序号**（1, 2, 3, ...） | 即使值相同，序号也不同 |
| **`RANK()`**       | 排名。**值相同时排名相同，但会跳过后续排名** (1, 1, 3, 4)    | 会出现排名“跳跃”       |
| **`DENSE_RANK()`** | 密集排名。**值相同时排名相同，且不会跳过后续排名** (1, 1, 2, 3) | 排名是连续的           |
| **NTILE()**        |                                                              |                        |

#### 前后位移窗口函数

这类函数用于访问当前行之前或之后的行，非常强大。

| 函数                  | 描述                            |
| :-------------------- | :------------------------------ |
| **`LAG(column, n)`**  | 返回当前行**之前第`n`行**的值。 |
| **`LEAD(column, n)`** | 返回当前行**之后第`n`行**的值。 |

#### 聚合窗口函数

所有常见的聚合函数（`SUM`, `AVG`, `COUNT`, `MAX`, `MIN`）都可以作为窗口函数使用，实现**<u>累计</u>计算**。





## 四、数据控制 (DCL)

数据控制语言：Data Control Language。用来授权或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，能够对数据库进行监视。

- `GRANT` - 授予用户访问权限
- `REVOKE` - 撤销用户访问权限
- `DENY` - 拒绝特定权限

## 五、事务控制 (TCL)

Transaction Control

- `COMMIT` - 提交事务
- `ROLLBACK` - 回滚事务
- `SAVEPOINT` - 在事务中设置保存点
- `SET TRANSACTION` - 设置事务特性
- `BEGIN`/`START TRANSACTION` - 开始事务



# 存储过程



# 第三部分 Hive SQL





# 第四部分 Spark SQL 









关系型数据库



# 第一节、关系型数据库



# 1、索引是什么？包括哪几类？

**索引的分类**包括**主键索引、唯一索引、普通索引、全文索引和组合索引**。选择合适的索引类型可以优化查询性能，但过多的索引可能影响数据写入速度。

## 一、按逻辑功能分类

### 1. 主键索引（Primary Key）

sql

```
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 主键索引
    name VARCHAR(100)
);
```



**特点：**

- 唯一且非空
- 通常是聚簇索引

### 2. 唯一索引（Unique Index）

sql

```
CREATE UNIQUE INDEX idx_email ON users(email);
```



**特点：**

- 保证列值唯一
- 允许NULL值（具体看数据库实现）

### 3. 普通索引（Normal Index）

sql

```
CREATE INDEX idx_name ON users(name);
```



**特点：**

- 最基本的索引类型
- 不保证唯一性

### 4. 复合索引（Composite Index）

sql

```
CREATE INDEX idx_name_age ON users(last_name, first_name, age);
```



**特点：**

- 多列组合索引
- 遵循最左前缀原则
- 支持索引覆盖查询

### 5. 前缀索引（Prefix Index）

sql

```
-- 只对字段的前N个字符建立索引
CREATE INDEX idx_name_prefix ON users(name(10));
```



**特点：**

- 减少索引大小
- 可能影响选择性

### 6. 函数索引（Function-based Index）

sql

```
-- Oracle/PostgreSQL
CREATE INDEX idx_upper_name ON users(UPPER(name));
-- MySQL 8.0+
CREATE INDEX idx_functional ON users((LOWER(email)));
```



**特点：**

- 基于函数或表达式
- 支持大小写不敏感查询等场景

## 二、按数据结构分类

### 1. B-Tree索引（最常用）

sql

```
-- MySQL/PostgreSQL的默认索引类型
CREATE INDEX idx_name ON users(name);
CREATE INDEX idx_composite ON users(last_name, first_name);
```



**特点：**

- 平衡多路搜索树
- 支持范围查询、排序、前缀匹配
- 适用于等值查询和范围查询

### 2. 哈希索引

sql

```
-- MySQL Memory引擎支持
CREATE INDEX idx_hash ON users(name) USING HASH;
-- PostgreSQL Hash索引
CREATE INDEX idx_hash ON users USING hash(email);
```



**特点：**

- 基于哈希表实现
- 只支持等值查询（=, IN）
- 不支持范围查询和排序
- 查询性能O(1)

### 3. 全文索引

sql

```
-- MySQL
CREATE FULLTEXT INDEX idx_content ON articles(content);
-- PostgreSQL
CREATE INDEX idx_gin ON documents USING gin(to_tsvector('english', content));
```



**特点：**

- 用于文本内容的全文搜索
- 支持关键词搜索、相关性排序

### 4. R-Tree索引（空间索引）

sql

```
-- MySQL
CREATE SPATIAL INDEX idx_location ON maps(coordinates);
-- PostgreSQL
CREATE INDEX idx_gist ON spatial_data USING gist(geometry_column);
```



**特点：**

- 用于地理空间数据
- 支持距离查询、范围查询等

### 5. 位图索引

sql

```
-- Oracle/PostgreSQL
CREATE BITMAP INDEX idx_status ON orders(status);
```



**特点：**

- 适用于低基数列（性别、状态等）
- 多个位图索引可以快速进行AND/OR操作

## 三、按物理存储分类

### 1. 聚簇索引（Clustered Index）

sql

```
-- InnoDB中主键自动成为聚簇索引
CREATE TABLE users (
    id INT PRIMARY KEY,  -- 聚簇索引
    name VARCHAR(100)
);
```



**特点：**

- 数据按索引顺序物理存储
- 一个表只能有一个聚簇索引
- 主键通常是聚簇索引

### 2. 非聚簇索引（Non-Clustered Index）

sql

```
-- 普通索引都是非聚簇索引
CREATE INDEX idx_email ON users(email);
```



**特点：**

- 索引和数据分开存储
- 一个表可以有多个非聚簇索引
- 需要回表查询

## 四、按覆盖范围分类

### 1. 覆盖索引（Covering Index）

sql

```
-- 索引包含查询所需的所有列
CREATE INDEX idx_covering ON users(id, name, email);
-- 查询时不需要回表
SELECT id, name FROM users WHERE id = 1;
```



**特点：**

- 索引包含查询需要的所有字段
- 避免回表操作，性能最佳

### 2. 部分索引（Partial Index）

sql

```
-- PostgreSQL/Oracle
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';
```



**特点：**

- 只对部分数据建立索引
- 减少索引大小，提高效率

# 什么是缓慢变化维（SCD）？如何处理？**

- **回答要点**：维度表中某些属性会随时间变化（如客户地址）。

  - **类型1**：直接覆盖旧值（不保留历史）。
  - **类型2**：添加新行，标记生效时间（保留历史）。
  - **类型3**：添加新列记录旧值（仅保留有限历史）。

  



# 数据库的三大范式是什么？

数据库的三大范式是：

1. **第一范式（1NF）**：确保每列的值都是不可分割的原子值。**确保原子性**
2. **第二范式（2NF）**：在满足第一范式的基础上，确保每个非主属性完全依赖于主键。**消除部分依赖。**
3. **第三范式（3NF）**：在满足第二范式的基础上，确保每个非主属性不传递依赖于主键。**消除传递依赖。**

# 事务ACID

在数据库管理中，ACID特性是确保数据库事务正确执行的四个基本要素，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这些特性保证了在多用户环境下，数据库能够提供可靠的事务处理。

## 原子性（Atomicity）

原子性意味着事务中的所有操作要么全部成功，要么全部失败。如果事务中的任何操作失败，整个事务将回滚到开始状态，就像这个事务从未执行过一样。这确保了事务是一个不可分割的工作单位。

## 一致性（Consistency）

一致性确保数据库在事务开始之前和结束之后保持一致状态。所有事务必须遵守数据库的规则，包括数据的完整性约束。无论事务的结果如何，数据库都必须保持一致性。

## 隔离性（Isolation）

隔离性保证了事务的独立性。即使多个事务同时执行，每个事务的操作和数据对其他事务都是隔离的。这避免了多个事务并发执行时可能出现的数据不一致问题。

## 持久性（Durability）

持久性意味着一旦事务提交，它对数据库的更改就是永久性的。即使发生系统故障，已提交的事务也不会丢失。





# 数据库分区分表

